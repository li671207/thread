# thread
多线程Demo

<pre>
核心概念
• 线程就是独立的执行路径；
• 在程序运行时，即使没有自己创建线程，后台也会存在多个线程，
如gc线程、主线程；
• main()称之为主线程,为系统的入口点，用于执行整个程序；
• 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排
调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的
干预的；
• 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控
制;
• 线程会带来额外的开销,如cpu调度时间,并发控制开销
• 每个线程在自己的工作内存交互，加载和存储主内存控制不当会
造成数据不一致。
</pre>

![Image 创建线程](https://raw.githubusercontent.com/li671207/thread/master/images/20190609151009.png)

<pre>
lamda
(params) -> expression
(params) -> statement
(params) -> { statements }
• λ希腊字母表中排序第十一位的字母，英语名称为
Lambda，
• 避免匿名内部类定义过多
• 其实质属于函数式编程的概念

new Thread(()->System.out.println("多线程学习)).start()
</pre>

![Image 线程状态1](https://raw.githubusercontent.com/li671207/thread/master/images/20190609160547.png)
![Image 线程状态2](https://raw.githubusercontent.com/li671207/thread/master/images/20190609155749.png)

<pre>
线程方法
• sleep () 
• 使线程停止运行一段时间，将处于阻塞状态
• 如果调用了sleep方法之后，没有其他等待执行的线程，这个时候当前线程不会马上恢复执行！
• join () 
• 阻塞指定线程等到另一个线程完成以后再继续执行。
• yield () 
• 让当前正在执行线程暂停，不是阻塞线程，而是将线程转入就绪状态;
• 调用了yield方法之后，如果没有其他等待执行的线程，此时当前线程就会马上恢复执行！
• setDaemon() 
• 可以将指定的线程设置成后台线程,守护线程;
• 创建用户线程的线程结束时，后台线程也随之消亡;
• 只能在线程启动之前把它设为后台线程
• setPriority(int newPriority) getPriority()
• 线程的优先级代表的是概率
• 范围从1到10，默认为5
• stop()停止线程
• 不推荐使用
</pre>

<pre>
sleep
• sleep(时间)指定当前线程阻塞的毫秒数;
• sleep存在异常InterruptedException;
• sleep时间达到后线程进入就绪状态;
• sleep可以模拟网络延时、倒计时等。
• 每一个对象都有一个锁，sleep不会释放锁;
</pre>

<pre>
线程方法
• sleep () 
• 使线程停止运行一段时间，将处于阻塞状态
• 如果调用了sleep方法之后，没有其他等待执行的线程，这个时候当前线程不会马上恢复执行！
• join () 
• 阻塞指定线程等到另一个线程完成以后再继续执行。
• yield () 
• 让当前正在执行线程暂停，不是阻塞线程，而是将线程转入就绪状态;
• 调用了yield方法之后，如果没有其他等待执行的线程，此时当前线程就会马上恢复执行！
• setDaemon() 
• 可以将指定的线程设置成后台线程,守护线程;
• 创建用户线程的线程结束时，后台线程也随之消亡;
• 只能在线程启动之前把它设为后台线程
• setPriority(int newPriority) getPriority()
• 线程的优先级代表的是概率
• 范围从1到10，默认为5
• stop()停止线程
• 不推荐使用
</pre>
<pre>
线程停止
• 不使用JDK提供的stop()/destroy()方法(它们本身也被JDK废弃了)。
• 提供一个boolean型的终止变量，当这个变量置为false，则终止线程的运行。
</pre>
<pre>
sleep
• sleep(时间)指定当前线程阻塞的毫秒数;
• sleep存在异常InterruptedException;
• sleep时间达到后线程进入就绪状态;
• sleep可以模拟网络延时、倒计时等。
• 每一个对象都有一个锁，sleep不会释放锁;
</pre>
<pre>
join
• join合并线程,待此线程执行完成后，再执行其他线程，其他线程阻塞
</pre>
<pre>
yield
• 礼让线程,让当前正在执行线程暂停
• 不是阻塞线程，而是将线程从运行状态转入就绪状态
• 让cpu调度器重新调度
</pre>
<pre>
priority
Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程。线程调度器按照线程的优先级决定应调度哪个线程来执行。
线程的优先级用数字表示，范围从1到10
• Thread.MIN_PRIORITY = 1
• Thread.MAX_PRIORITY = 10
• Thread.NORM_PRIORITY = 5
使用下述方法获得或设置线程对象的优先级。
• int getPriority();
• void setPriority(int newPriority);
优先级的设定建议在start()调用前
注意：优先级低只是意味着获得调度的概率低。并不是绝对先调用优先级高后调用优先级低的线程。

daemon
• 线程分为用户线程和守护线程;
• 虚拟机必须确保用户线程执行完毕;
• 虚拟机不用等待守护线程执行完毕;
• 如后台记录操作日志、监控内存使用等

其它常用方法
isAlive() 判断线程是否还活着,即线程是否还未终止
setName() 给线程起一个名字
getName() 获取线程的名字
currentThread() 取得当前正在运行的线程对象，也就是获取自己本身
</pre>

<pre>
<b>线程同步</b>
线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕后，
下一个线程再使用。
</pre>
<pre>
线程同步
由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突的问题。为了保证数据在方法中被访问时的正确性，
在访问时加入锁机制(synchronized)，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。
存在以下问题：
• 一个线程持有锁会导致其它所有需要此锁的线程挂起;
• 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题;
• 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题。

由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需针对方法提出一套机制，
这套机制就是synchronized关键字，它包括两种用法：synchronized 方法和 synchronized 块。
• 同步方法
public synchronized void method(int args) {}synchronized 方法控制对“成员变量|类变量”对象的访问：
每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，
方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。

缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。

• 同步块
synchronized (obj){ },obj称之为同步监视器
• obj可以是任何对象，但是推荐使用共享资源作为同步监视器
• 同步方法中无需指定同步监视器，因为同步方法的同步监视器是this即该对象本身，或class即类的模子
• 同步监视器的执行过程
• 第一个线程访问，锁定同步监视器，执行其中代码
• 第二个线程访问，发现同步监视器被锁定，无法访问
• 第一个线程访问完毕，解锁同步监视器
• 第二个线程访问，发现同步监视器未锁，锁定并访问
</pre>
<pre>
死锁:多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个
或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对
象的锁”时，就可能会发生“死锁”的问题。
</pre>

<pre>
<b>线程协作</b>
cooperation
生产者消费者模式

线程通信
分析:这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件
对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后， 又需要马上通知消费者消费
对于消费者，在消费之后，要通知生产者已经消费结束，需要继续生产新产品以供消费
在生产者消费者问题中，仅有synchronized是不够的
synchronized可阻止并发更新同一个共享资源，实现了同步
synchronized不能用来实现不同线程之间的消息传递（通信）

解决方式1:并发协作模型“生产者/消费者模式” 管程法
生产者:负责生产数据的模块(这里模块可能是：方法、对象、线程、进程);
消费者:负责处理数据的模块(这里模块可能是：方法、对象、线程、进程);
缓冲区:消费者不能直接使用生产者的数据，它们之间有个“缓冲区”;
生产者将生产好的数据放入“缓冲区”，消费者从“缓冲区”拿要处理的数据。
解耦、提高效率

解决方式2:并发协作模型“生产者/消费者模式” 信号灯法
</pre>


<table>
<tr>
<td>final void wait()</td>
<td>表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</td>
</tr>
<tr>
<td>final void wait(long timeout)</td>
<td>指定等待的毫秒数</td>
</tr>
<tr>
<td>final void notifiy()</td>
<td>唤醒一个处于等待状态的线程</td>
</tr>
<tr>
<td>final void notifyAll()</td>
<td>唤醒同一个对象上所有调用wait()方法的线 程，优先级别高的线程优先调度</td>
</tr>
</table>
<pre>
指令重排：
	1、抓取指令
	2、存储值到工作台
	3、操作计算
	4、写回
	
</pre>